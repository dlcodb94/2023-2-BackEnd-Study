1. 객체지향 프로그래밍

======================================================================

1.1 장점과 단점

- 장점: 코드 재사용이 용이하며 유지보수가 쉽다. 대형프로젝트에 적합하다.
- 단점: 처리속도가 상대적으로 느리다. 객체가 많으면 용량이 커진다. 설계시 많은 시간과 노력이 필요하다.

======================================================================

1.2 특징

a. 추상화(abstraction)
: 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
- abstract class : abstract method를 선언하여 상속을 통해 자식 클래스가 그 메서드를 완성하도록 한다. 미완성 클래스이기 때문에 객체를 생성할 수 없다.
abstract class A { }
public class B extends A { }

- interface : 어떤 객체의 역할과 구현을 분리하여  객체들 간의 관계를 연결하는 역할. 구현부가 있는 일반 메서드, 일반 멤버 변수를 가질 수 없다. 다중상속이 가능하다.
public interface A { }
public class B implements A { }

추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜놓은 것으로 상속 관계를 타고 올라갔을 때, 같은 부모 클래스를 상속하며, 부모 클래스가 가진 기능들을 구현해야 하는 경우에 사용된다.
인터페이스는 상속 관계를 타고 올라갔을 때, 다른 부모 클래스를 상속하더라도 같은 기능이 필요한 경우에 사용된다.

 상위 클래스는 다중 상속이 불가능하기 때문에 하나의 클래스에서 하위 클래스에 물려줄 특성이 풍부할수록 좋고, 인터페이스는 다중 상속이 가능하기 때문에 각각의 인터페이스는 목적에 맞는 최소한의 메서드(구현을 강제할)를 선언하는 것이 좋다.


b. 캡슐화(encapsulation)
: 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 은닉하는 것.
- private : 외부에서 속성과 기능을 임의로 바꾸지 않게 하기 위함.
- public
- protected
* friend : C++에서만 지원. 또한 연산자 오버로딩은 자바에서 지원하지 않는다.


c. 상속(inheritance)
: 상위 클래스의 속성과 기능들을 하위 클래스가 사용할 수 있도록 하는 것.
이때, 상위 클래스의 private 멤버는 상속되지 않는다(static 변수 상속 가능). 하위 클래스에서 객체를 생성하면 상위 클래스도 메모리가 할당된다. (자식 객체 생성하라는 코드 실행 → 부모 객체 생성 → 자식 객체 생성) 만약 동일한 이름의 변수가 상위 클래스와 하위 클래스에 존재한다면 상위 클래스의 변수는 가려진다. 


d. 다형성(polymorphism)
: 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있음
- overriding : 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것. 자식 클래스에서 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 부모 클래스의 메소드와 모두 같아야 한다. 
- overloading : 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다. 리턴 값만 다른 것은 오버로딩을 할 수 없다는 것이다.


======================================================================

1.3 객체지향 설계 원칙(SOLID)

1. 단일 책임원칙(Single Responsibility Principle)
하나의 클래스(객체)는 하나의 기능만을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러개 설계하라는 원칙이다. 만일 하나의 클래스에 기능(책임)이 여러개 있다면 수정을 해야할 필요가 있을 때 수정해야할 코드가 많아져 유지보수가 힘들어진다.

2. 개방-폐쇄원칙(Open Close Principle)
클래스는 기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 한다. 이는 추상화 사용을 통한 관계 구축을 권장함을 의미한다.

3. 리스코프 치환 원칙(Liskov Substitution Principle)
원칙은 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙이다. 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 한다.

4. 인터페이스 분리 원칙 (Interface Segregation Principle)
SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조하는 것으로 보면 된다. ISP 원칙은 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표이다. 인터페이스는 피치못할 사정이 있지 않으면 수정하지 않는 것이 좋다.

5. 의존관계 역전 원칙 (Dependency Inversion Principle)
어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class(변화하는 것)를 직접 참조하는 것이 아니라 그 대상의 상위 요소(변하지 않는 것)를 참조하라는 원칙이다. 


======================================================================

2. JAVA

자바는 객체지향 언어로, 객체지향의 특징 4가지(추상화, 캡슐화, 상속성, 다형성)을 지원한다. 자바 실행환경이 설치되어 있는 모든 운영체제에서 실행 가능하다. 또한 자바는 컴파일 언어인 동시에 인터프리터 언어이며 오픈소스 라이브러리가 풍부하다.
